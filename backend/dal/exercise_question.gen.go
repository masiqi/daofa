// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"
	"strings"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gen/helper"

	"gorm.io/plugin/dbresolver"

	"daofa/backend/model"
)

func newExerciseQuestion(db *gorm.DB, opts ...gen.DOOption) exerciseQuestion {
	_exerciseQuestion := exerciseQuestion{}

	_exerciseQuestion.exerciseQuestionDo.UseDB(db, opts...)
	_exerciseQuestion.exerciseQuestionDo.UseModel(&model.ExerciseQuestion{})

	tableName := _exerciseQuestion.exerciseQuestionDo.TableName()
	_exerciseQuestion.ALL = field.NewAsterisk(tableName)
	_exerciseQuestion.ID = field.NewInt32(tableName, "id")
	_exerciseQuestion.MaterialID = field.NewInt32(tableName, "material_id")
	_exerciseQuestion.Question = field.NewString(tableName, "question")
	_exerciseQuestion.Answer = field.NewString(tableName, "answer")
	_exerciseQuestion.Explanation = field.NewString(tableName, "explanation")
	_exerciseQuestion.CreatedAt = field.NewTime(tableName, "created_at")
	_exerciseQuestion.UpdatedAt = field.NewTime(tableName, "updated_at")

	_exerciseQuestion.fillFieldMap()

	return _exerciseQuestion
}

type exerciseQuestion struct {
	exerciseQuestionDo

	ALL         field.Asterisk
	ID          field.Int32
	MaterialID  field.Int32
	Question    field.String
	Answer      field.String
	Explanation field.String
	CreatedAt   field.Time
	UpdatedAt   field.Time

	fieldMap map[string]field.Expr
}

func (e exerciseQuestion) Table(newTableName string) *exerciseQuestion {
	e.exerciseQuestionDo.UseTable(newTableName)
	return e.updateTableName(newTableName)
}

func (e exerciseQuestion) As(alias string) *exerciseQuestion {
	e.exerciseQuestionDo.DO = *(e.exerciseQuestionDo.As(alias).(*gen.DO))
	return e.updateTableName(alias)
}

func (e *exerciseQuestion) updateTableName(table string) *exerciseQuestion {
	e.ALL = field.NewAsterisk(table)
	e.ID = field.NewInt32(table, "id")
	e.MaterialID = field.NewInt32(table, "material_id")
	e.Question = field.NewString(table, "question")
	e.Answer = field.NewString(table, "answer")
	e.Explanation = field.NewString(table, "explanation")
	e.CreatedAt = field.NewTime(table, "created_at")
	e.UpdatedAt = field.NewTime(table, "updated_at")

	e.fillFieldMap()

	return e
}

func (e *exerciseQuestion) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := e.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (e *exerciseQuestion) fillFieldMap() {
	e.fieldMap = make(map[string]field.Expr, 7)
	e.fieldMap["id"] = e.ID
	e.fieldMap["material_id"] = e.MaterialID
	e.fieldMap["question"] = e.Question
	e.fieldMap["answer"] = e.Answer
	e.fieldMap["explanation"] = e.Explanation
	e.fieldMap["created_at"] = e.CreatedAt
	e.fieldMap["updated_at"] = e.UpdatedAt
}

func (e exerciseQuestion) clone(db *gorm.DB) exerciseQuestion {
	e.exerciseQuestionDo.ReplaceConnPool(db.Statement.ConnPool)
	return e
}

func (e exerciseQuestion) replaceDB(db *gorm.DB) exerciseQuestion {
	e.exerciseQuestionDo.ReplaceDB(db)
	return e
}

type exerciseQuestionDo struct{ gen.DO }

type IExerciseQuestionDo interface {
	gen.SubQuery
	Debug() IExerciseQuestionDo
	WithContext(ctx context.Context) IExerciseQuestionDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IExerciseQuestionDo
	WriteDB() IExerciseQuestionDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IExerciseQuestionDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IExerciseQuestionDo
	Not(conds ...gen.Condition) IExerciseQuestionDo
	Or(conds ...gen.Condition) IExerciseQuestionDo
	Select(conds ...field.Expr) IExerciseQuestionDo
	Where(conds ...gen.Condition) IExerciseQuestionDo
	Order(conds ...field.Expr) IExerciseQuestionDo
	Distinct(cols ...field.Expr) IExerciseQuestionDo
	Omit(cols ...field.Expr) IExerciseQuestionDo
	Join(table schema.Tabler, on ...field.Expr) IExerciseQuestionDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IExerciseQuestionDo
	RightJoin(table schema.Tabler, on ...field.Expr) IExerciseQuestionDo
	Group(cols ...field.Expr) IExerciseQuestionDo
	Having(conds ...gen.Condition) IExerciseQuestionDo
	Limit(limit int) IExerciseQuestionDo
	Offset(offset int) IExerciseQuestionDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IExerciseQuestionDo
	Unscoped() IExerciseQuestionDo
	Create(values ...*model.ExerciseQuestion) error
	CreateInBatches(values []*model.ExerciseQuestion, batchSize int) error
	Save(values ...*model.ExerciseQuestion) error
	First() (*model.ExerciseQuestion, error)
	Take() (*model.ExerciseQuestion, error)
	Last() (*model.ExerciseQuestion, error)
	Find() ([]*model.ExerciseQuestion, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ExerciseQuestion, err error)
	FindInBatches(result *[]*model.ExerciseQuestion, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ExerciseQuestion) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IExerciseQuestionDo
	Assign(attrs ...field.AssignExpr) IExerciseQuestionDo
	Joins(fields ...field.RelationField) IExerciseQuestionDo
	Preload(fields ...field.RelationField) IExerciseQuestionDo
	FirstOrInit() (*model.ExerciseQuestion, error)
	FirstOrCreate() (*model.ExerciseQuestion, error)
	FindByPage(offset int, limit int) (result []*model.ExerciseQuestion, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IExerciseQuestionDo
	UnderlyingDB() *gorm.DB
	schema.Tabler

	CreateQuestion(materialID uint, question string, answer string, explanation *string) (err error)
	UpdateQuestion(id uint, question string, answer string, explanation *string) (err error)
	DeleteQuestion(id uint) (err error)
	ListQuestionsWithPagination(materialID uint, offset int, limit int) (result []*model.ExerciseQuestion, err error)
	CountQuestions(materialID uint) (result int64, err error)
	GetQuestionByID(id uint) (result *model.ExerciseQuestion, err error)
	SearchQuestions(materialID uint, question string, offset int, limit int) (result []*model.ExerciseQuestion, err error)
}

// INSERT INTO @@table (material_id, question, answer, explanation) VALUES (@materialID, @question, @answer, @explanation)
func (e exerciseQuestionDo) CreateQuestion(materialID uint, question string, answer string, explanation *string) (err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, materialID)
	params = append(params, question)
	params = append(params, answer)
	params = append(params, explanation)
	generateSQL.WriteString("INSERT INTO exercise_question (material_id, question, answer, explanation) VALUES (?, ?, ?, ?) ")

	var executeSQL *gorm.DB
	executeSQL = e.UnderlyingDB().Exec(generateSQL.String(), params...) // ignore_security_alert
	err = executeSQL.Error

	return
}

// UPDATE @@table SET
//
//	{{if question != ""}}question=@question,{{end}}
//	{{if answer != ""}}answer=@answer,{{end}}
//	{{if explanation != nil}}explanation=@explanation,{{end}}
//
// WHERE id=@id
func (e exerciseQuestionDo) UpdateQuestion(id uint, question string, answer string, explanation *string) (err error) {
	var params []interface{}

	var generateSQL strings.Builder
	generateSQL.WriteString("UPDATE exercise_question SET ")
	if question != "" {
		params = append(params, question)
		generateSQL.WriteString("question=?, ")
	}
	if answer != "" {
		params = append(params, answer)
		generateSQL.WriteString("answer=?, ")
	}
	if explanation != nil {
		params = append(params, explanation)
		generateSQL.WriteString("explanation=?, ")
	}
	params = append(params, id)
	generateSQL.WriteString("WHERE id=? ")

	var executeSQL *gorm.DB
	executeSQL = e.UnderlyingDB().Exec(generateSQL.String(), params...) // ignore_security_alert
	err = executeSQL.Error

	return
}

// DELETE FROM @@table WHERE id=@id
func (e exerciseQuestionDo) DeleteQuestion(id uint) (err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, id)
	generateSQL.WriteString("DELETE FROM exercise_question WHERE id=? ")

	var executeSQL *gorm.DB
	executeSQL = e.UnderlyingDB().Exec(generateSQL.String(), params...) // ignore_security_alert
	err = executeSQL.Error

	return
}

// SELECT * FROM @@table WHERE material_id=@materialID LIMIT @limit OFFSET @offset
func (e exerciseQuestionDo) ListQuestionsWithPagination(materialID uint, offset int, limit int) (result []*model.ExerciseQuestion, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, materialID)
	params = append(params, limit)
	params = append(params, offset)
	generateSQL.WriteString("SELECT * FROM exercise_question WHERE material_id=? LIMIT ? OFFSET ? ")

	var executeSQL *gorm.DB
	executeSQL = e.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// SELECT COUNT(*) FROM @@table WHERE material_id=@materialID
func (e exerciseQuestionDo) CountQuestions(materialID uint) (result int64, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, materialID)
	generateSQL.WriteString("SELECT COUNT(*) FROM exercise_question WHERE material_id=? ")

	var executeSQL *gorm.DB
	executeSQL = e.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// SELECT * FROM @@table WHERE id=@id LIMIT 1
func (e exerciseQuestionDo) GetQuestionByID(id uint) (result *model.ExerciseQuestion, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, id)
	generateSQL.WriteString("SELECT * FROM exercise_question WHERE id=? LIMIT 1 ")

	var executeSQL *gorm.DB
	executeSQL = e.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// SELECT * FROM @@table
//
//	{{where}}
//	  material_id=@materialID
//	  {{if question != ""}}AND question LIKE CONCAT('%', @question, '%'){{end}}
//	{{end}}
//
// LIMIT @limit OFFSET @offset
func (e exerciseQuestionDo) SearchQuestions(materialID uint, question string, offset int, limit int) (result []*model.ExerciseQuestion, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	generateSQL.WriteString("SELECT * FROM exercise_question ")
	var whereSQL0 strings.Builder
	params = append(params, materialID)
	whereSQL0.WriteString("material_id=? ")
	if question != "" {
		params = append(params, question)
		whereSQL0.WriteString("AND question LIKE CONCAT('%', ?, '%') ")
	}
	helper.JoinWhereBuilder(&generateSQL, whereSQL0)
	params = append(params, limit)
	params = append(params, offset)
	generateSQL.WriteString("LIMIT ? OFFSET ? ")

	var executeSQL *gorm.DB
	executeSQL = e.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

func (e exerciseQuestionDo) Debug() IExerciseQuestionDo {
	return e.withDO(e.DO.Debug())
}

func (e exerciseQuestionDo) WithContext(ctx context.Context) IExerciseQuestionDo {
	return e.withDO(e.DO.WithContext(ctx))
}

func (e exerciseQuestionDo) ReadDB() IExerciseQuestionDo {
	return e.Clauses(dbresolver.Read)
}

func (e exerciseQuestionDo) WriteDB() IExerciseQuestionDo {
	return e.Clauses(dbresolver.Write)
}

func (e exerciseQuestionDo) Session(config *gorm.Session) IExerciseQuestionDo {
	return e.withDO(e.DO.Session(config))
}

func (e exerciseQuestionDo) Clauses(conds ...clause.Expression) IExerciseQuestionDo {
	return e.withDO(e.DO.Clauses(conds...))
}

func (e exerciseQuestionDo) Returning(value interface{}, columns ...string) IExerciseQuestionDo {
	return e.withDO(e.DO.Returning(value, columns...))
}

func (e exerciseQuestionDo) Not(conds ...gen.Condition) IExerciseQuestionDo {
	return e.withDO(e.DO.Not(conds...))
}

func (e exerciseQuestionDo) Or(conds ...gen.Condition) IExerciseQuestionDo {
	return e.withDO(e.DO.Or(conds...))
}

func (e exerciseQuestionDo) Select(conds ...field.Expr) IExerciseQuestionDo {
	return e.withDO(e.DO.Select(conds...))
}

func (e exerciseQuestionDo) Where(conds ...gen.Condition) IExerciseQuestionDo {
	return e.withDO(e.DO.Where(conds...))
}

func (e exerciseQuestionDo) Order(conds ...field.Expr) IExerciseQuestionDo {
	return e.withDO(e.DO.Order(conds...))
}

func (e exerciseQuestionDo) Distinct(cols ...field.Expr) IExerciseQuestionDo {
	return e.withDO(e.DO.Distinct(cols...))
}

func (e exerciseQuestionDo) Omit(cols ...field.Expr) IExerciseQuestionDo {
	return e.withDO(e.DO.Omit(cols...))
}

func (e exerciseQuestionDo) Join(table schema.Tabler, on ...field.Expr) IExerciseQuestionDo {
	return e.withDO(e.DO.Join(table, on...))
}

func (e exerciseQuestionDo) LeftJoin(table schema.Tabler, on ...field.Expr) IExerciseQuestionDo {
	return e.withDO(e.DO.LeftJoin(table, on...))
}

func (e exerciseQuestionDo) RightJoin(table schema.Tabler, on ...field.Expr) IExerciseQuestionDo {
	return e.withDO(e.DO.RightJoin(table, on...))
}

func (e exerciseQuestionDo) Group(cols ...field.Expr) IExerciseQuestionDo {
	return e.withDO(e.DO.Group(cols...))
}

func (e exerciseQuestionDo) Having(conds ...gen.Condition) IExerciseQuestionDo {
	return e.withDO(e.DO.Having(conds...))
}

func (e exerciseQuestionDo) Limit(limit int) IExerciseQuestionDo {
	return e.withDO(e.DO.Limit(limit))
}

func (e exerciseQuestionDo) Offset(offset int) IExerciseQuestionDo {
	return e.withDO(e.DO.Offset(offset))
}

func (e exerciseQuestionDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IExerciseQuestionDo {
	return e.withDO(e.DO.Scopes(funcs...))
}

func (e exerciseQuestionDo) Unscoped() IExerciseQuestionDo {
	return e.withDO(e.DO.Unscoped())
}

func (e exerciseQuestionDo) Create(values ...*model.ExerciseQuestion) error {
	if len(values) == 0 {
		return nil
	}
	return e.DO.Create(values)
}

func (e exerciseQuestionDo) CreateInBatches(values []*model.ExerciseQuestion, batchSize int) error {
	return e.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (e exerciseQuestionDo) Save(values ...*model.ExerciseQuestion) error {
	if len(values) == 0 {
		return nil
	}
	return e.DO.Save(values)
}

func (e exerciseQuestionDo) First() (*model.ExerciseQuestion, error) {
	if result, err := e.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ExerciseQuestion), nil
	}
}

func (e exerciseQuestionDo) Take() (*model.ExerciseQuestion, error) {
	if result, err := e.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ExerciseQuestion), nil
	}
}

func (e exerciseQuestionDo) Last() (*model.ExerciseQuestion, error) {
	if result, err := e.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ExerciseQuestion), nil
	}
}

func (e exerciseQuestionDo) Find() ([]*model.ExerciseQuestion, error) {
	result, err := e.DO.Find()
	return result.([]*model.ExerciseQuestion), err
}

func (e exerciseQuestionDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ExerciseQuestion, err error) {
	buf := make([]*model.ExerciseQuestion, 0, batchSize)
	err = e.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (e exerciseQuestionDo) FindInBatches(result *[]*model.ExerciseQuestion, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return e.DO.FindInBatches(result, batchSize, fc)
}

func (e exerciseQuestionDo) Attrs(attrs ...field.AssignExpr) IExerciseQuestionDo {
	return e.withDO(e.DO.Attrs(attrs...))
}

func (e exerciseQuestionDo) Assign(attrs ...field.AssignExpr) IExerciseQuestionDo {
	return e.withDO(e.DO.Assign(attrs...))
}

func (e exerciseQuestionDo) Joins(fields ...field.RelationField) IExerciseQuestionDo {
	for _, _f := range fields {
		e = *e.withDO(e.DO.Joins(_f))
	}
	return &e
}

func (e exerciseQuestionDo) Preload(fields ...field.RelationField) IExerciseQuestionDo {
	for _, _f := range fields {
		e = *e.withDO(e.DO.Preload(_f))
	}
	return &e
}

func (e exerciseQuestionDo) FirstOrInit() (*model.ExerciseQuestion, error) {
	if result, err := e.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ExerciseQuestion), nil
	}
}

func (e exerciseQuestionDo) FirstOrCreate() (*model.ExerciseQuestion, error) {
	if result, err := e.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ExerciseQuestion), nil
	}
}

func (e exerciseQuestionDo) FindByPage(offset int, limit int) (result []*model.ExerciseQuestion, count int64, err error) {
	result, err = e.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = e.Offset(-1).Limit(-1).Count()
	return
}

func (e exerciseQuestionDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = e.Count()
	if err != nil {
		return
	}

	err = e.Offset(offset).Limit(limit).Scan(result)
	return
}

func (e exerciseQuestionDo) Scan(result interface{}) (err error) {
	return e.DO.Scan(result)
}

func (e exerciseQuestionDo) Delete(models ...*model.ExerciseQuestion) (result gen.ResultInfo, err error) {
	return e.DO.Delete(models)
}

func (e *exerciseQuestionDo) withDO(do gen.Dao) *exerciseQuestionDo {
	e.DO = *do.(*gen.DO)
	return e
}
