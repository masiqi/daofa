// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dal

import (
	"context"
	"strings"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"daofa/backend/model"
)

func newQuestionKnowledgePoint(db *gorm.DB, opts ...gen.DOOption) questionKnowledgePoint {
	_questionKnowledgePoint := questionKnowledgePoint{}

	_questionKnowledgePoint.questionKnowledgePointDo.UseDB(db, opts...)
	_questionKnowledgePoint.questionKnowledgePointDo.UseModel(&model.QuestionKnowledgePoint{})

	tableName := _questionKnowledgePoint.questionKnowledgePointDo.TableName()
	_questionKnowledgePoint.ALL = field.NewAsterisk(tableName)
	_questionKnowledgePoint.ID = field.NewInt32(tableName, "id")
	_questionKnowledgePoint.QuestionID = field.NewInt32(tableName, "question_id")
	_questionKnowledgePoint.KnowledgePointID = field.NewInt32(tableName, "knowledge_point_id")
	_questionKnowledgePoint.CreatedAt = field.NewTime(tableName, "created_at")

	_questionKnowledgePoint.fillFieldMap()

	return _questionKnowledgePoint
}

type questionKnowledgePoint struct {
	questionKnowledgePointDo

	ALL              field.Asterisk
	ID               field.Int32
	QuestionID       field.Int32
	KnowledgePointID field.Int32
	CreatedAt        field.Time

	fieldMap map[string]field.Expr
}

func (q questionKnowledgePoint) Table(newTableName string) *questionKnowledgePoint {
	q.questionKnowledgePointDo.UseTable(newTableName)
	return q.updateTableName(newTableName)
}

func (q questionKnowledgePoint) As(alias string) *questionKnowledgePoint {
	q.questionKnowledgePointDo.DO = *(q.questionKnowledgePointDo.As(alias).(*gen.DO))
	return q.updateTableName(alias)
}

func (q *questionKnowledgePoint) updateTableName(table string) *questionKnowledgePoint {
	q.ALL = field.NewAsterisk(table)
	q.ID = field.NewInt32(table, "id")
	q.QuestionID = field.NewInt32(table, "question_id")
	q.KnowledgePointID = field.NewInt32(table, "knowledge_point_id")
	q.CreatedAt = field.NewTime(table, "created_at")

	q.fillFieldMap()

	return q
}

func (q *questionKnowledgePoint) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := q.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (q *questionKnowledgePoint) fillFieldMap() {
	q.fieldMap = make(map[string]field.Expr, 4)
	q.fieldMap["id"] = q.ID
	q.fieldMap["question_id"] = q.QuestionID
	q.fieldMap["knowledge_point_id"] = q.KnowledgePointID
	q.fieldMap["created_at"] = q.CreatedAt
}

func (q questionKnowledgePoint) clone(db *gorm.DB) questionKnowledgePoint {
	q.questionKnowledgePointDo.ReplaceConnPool(db.Statement.ConnPool)
	return q
}

func (q questionKnowledgePoint) replaceDB(db *gorm.DB) questionKnowledgePoint {
	q.questionKnowledgePointDo.ReplaceDB(db)
	return q
}

type questionKnowledgePointDo struct{ gen.DO }

type IQuestionKnowledgePointDo interface {
	gen.SubQuery
	Debug() IQuestionKnowledgePointDo
	WithContext(ctx context.Context) IQuestionKnowledgePointDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IQuestionKnowledgePointDo
	WriteDB() IQuestionKnowledgePointDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IQuestionKnowledgePointDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IQuestionKnowledgePointDo
	Not(conds ...gen.Condition) IQuestionKnowledgePointDo
	Or(conds ...gen.Condition) IQuestionKnowledgePointDo
	Select(conds ...field.Expr) IQuestionKnowledgePointDo
	Where(conds ...gen.Condition) IQuestionKnowledgePointDo
	Order(conds ...field.Expr) IQuestionKnowledgePointDo
	Distinct(cols ...field.Expr) IQuestionKnowledgePointDo
	Omit(cols ...field.Expr) IQuestionKnowledgePointDo
	Join(table schema.Tabler, on ...field.Expr) IQuestionKnowledgePointDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IQuestionKnowledgePointDo
	RightJoin(table schema.Tabler, on ...field.Expr) IQuestionKnowledgePointDo
	Group(cols ...field.Expr) IQuestionKnowledgePointDo
	Having(conds ...gen.Condition) IQuestionKnowledgePointDo
	Limit(limit int) IQuestionKnowledgePointDo
	Offset(offset int) IQuestionKnowledgePointDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IQuestionKnowledgePointDo
	Unscoped() IQuestionKnowledgePointDo
	Create(values ...*model.QuestionKnowledgePoint) error
	CreateInBatches(values []*model.QuestionKnowledgePoint, batchSize int) error
	Save(values ...*model.QuestionKnowledgePoint) error
	First() (*model.QuestionKnowledgePoint, error)
	Take() (*model.QuestionKnowledgePoint, error)
	Last() (*model.QuestionKnowledgePoint, error)
	Find() ([]*model.QuestionKnowledgePoint, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.QuestionKnowledgePoint, err error)
	FindInBatches(result *[]*model.QuestionKnowledgePoint, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.QuestionKnowledgePoint) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IQuestionKnowledgePointDo
	Assign(attrs ...field.AssignExpr) IQuestionKnowledgePointDo
	Joins(fields ...field.RelationField) IQuestionKnowledgePointDo
	Preload(fields ...field.RelationField) IQuestionKnowledgePointDo
	FirstOrInit() (*model.QuestionKnowledgePoint, error)
	FirstOrCreate() (*model.QuestionKnowledgePoint, error)
	FindByPage(offset int, limit int) (result []*model.QuestionKnowledgePoint, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IQuestionKnowledgePointDo
	UnderlyingDB() *gorm.DB
	schema.Tabler

	CreateQuestionKnowledgePoint(questionID int32, knowledgePointID int32) (err error)
	DeleteQuestionKnowledgePoint(questionID int32, knowledgePointID int32) (err error)
	GetKnowledgePointsByQuestionIDWithPagination(questionID int32, offset int, limit int) (result []*model.QuestionKnowledgePoint, err error)
	CountKnowledgePointsByQuestionID(questionID int32) (result int64, err error)
	GetQuestionsByKnowledgePointIDWithPagination(knowledgePointID int32, offset int, limit int) (result []*model.QuestionKnowledgePoint, err error)
	CountQuestionsByKnowledgePointID(knowledgePointID int32) (result int64, err error)
	GetKnowledgePointsByQuestionID(questionID int32) (result []*model.QuestionKnowledgePoint, err error)
}

// INSERT INTO @@table (question_id, knowledge_point_id) VALUES (@questionID, @knowledgePointID)
func (q questionKnowledgePointDo) CreateQuestionKnowledgePoint(questionID int32, knowledgePointID int32) (err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, questionID)
	params = append(params, knowledgePointID)
	generateSQL.WriteString("INSERT INTO question_knowledge_point (question_id, knowledge_point_id) VALUES (?, ?) ")

	var executeSQL *gorm.DB
	executeSQL = q.UnderlyingDB().Exec(generateSQL.String(), params...) // ignore_security_alert
	err = executeSQL.Error

	return
}

// DELETE FROM @@table WHERE question_id=@questionID AND knowledge_point_id=@knowledgePointID
func (q questionKnowledgePointDo) DeleteQuestionKnowledgePoint(questionID int32, knowledgePointID int32) (err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, questionID)
	params = append(params, knowledgePointID)
	generateSQL.WriteString("DELETE FROM question_knowledge_point WHERE question_id=? AND knowledge_point_id=? ")

	var executeSQL *gorm.DB
	executeSQL = q.UnderlyingDB().Exec(generateSQL.String(), params...) // ignore_security_alert
	err = executeSQL.Error

	return
}

// SELECT * FROM @@table WHERE question_id=@questionID LIMIT @limit OFFSET @offset
func (q questionKnowledgePointDo) GetKnowledgePointsByQuestionIDWithPagination(questionID int32, offset int, limit int) (result []*model.QuestionKnowledgePoint, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, questionID)
	params = append(params, limit)
	params = append(params, offset)
	generateSQL.WriteString("SELECT * FROM question_knowledge_point WHERE question_id=? LIMIT ? OFFSET ? ")

	var executeSQL *gorm.DB
	executeSQL = q.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// SELECT COUNT(*) FROM @@table WHERE question_id=@questionID
func (q questionKnowledgePointDo) CountKnowledgePointsByQuestionID(questionID int32) (result int64, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, questionID)
	generateSQL.WriteString("SELECT COUNT(*) FROM question_knowledge_point WHERE question_id=? ")

	var executeSQL *gorm.DB
	executeSQL = q.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// SELECT * FROM @@table WHERE knowledge_point_id=@knowledgePointID LIMIT @limit OFFSET @offset
func (q questionKnowledgePointDo) GetQuestionsByKnowledgePointIDWithPagination(knowledgePointID int32, offset int, limit int) (result []*model.QuestionKnowledgePoint, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, knowledgePointID)
	params = append(params, limit)
	params = append(params, offset)
	generateSQL.WriteString("SELECT * FROM question_knowledge_point WHERE knowledge_point_id=? LIMIT ? OFFSET ? ")

	var executeSQL *gorm.DB
	executeSQL = q.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// SELECT COUNT(*) FROM @@table WHERE knowledge_point_id=@knowledgePointID
func (q questionKnowledgePointDo) CountQuestionsByKnowledgePointID(knowledgePointID int32) (result int64, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, knowledgePointID)
	generateSQL.WriteString("SELECT COUNT(*) FROM question_knowledge_point WHERE knowledge_point_id=? ")

	var executeSQL *gorm.DB
	executeSQL = q.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// SELECT k.* FROM @@table qkp
// JOIN knowledge_point k ON qkp.knowledge_point_id = k.id
// WHERE qkp.question_id = @questionID
func (q questionKnowledgePointDo) GetKnowledgePointsByQuestionID(questionID int32) (result []*model.QuestionKnowledgePoint, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, questionID)
	generateSQL.WriteString("SELECT k.* FROM question_knowledge_point qkp JOIN knowledge_point k ON qkp.knowledge_point_id = k.id WHERE qkp.question_id = ? ")

	var executeSQL *gorm.DB
	executeSQL = q.UnderlyingDB().Raw(generateSQL.String(), params...).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

func (q questionKnowledgePointDo) Debug() IQuestionKnowledgePointDo {
	return q.withDO(q.DO.Debug())
}

func (q questionKnowledgePointDo) WithContext(ctx context.Context) IQuestionKnowledgePointDo {
	return q.withDO(q.DO.WithContext(ctx))
}

func (q questionKnowledgePointDo) ReadDB() IQuestionKnowledgePointDo {
	return q.Clauses(dbresolver.Read)
}

func (q questionKnowledgePointDo) WriteDB() IQuestionKnowledgePointDo {
	return q.Clauses(dbresolver.Write)
}

func (q questionKnowledgePointDo) Session(config *gorm.Session) IQuestionKnowledgePointDo {
	return q.withDO(q.DO.Session(config))
}

func (q questionKnowledgePointDo) Clauses(conds ...clause.Expression) IQuestionKnowledgePointDo {
	return q.withDO(q.DO.Clauses(conds...))
}

func (q questionKnowledgePointDo) Returning(value interface{}, columns ...string) IQuestionKnowledgePointDo {
	return q.withDO(q.DO.Returning(value, columns...))
}

func (q questionKnowledgePointDo) Not(conds ...gen.Condition) IQuestionKnowledgePointDo {
	return q.withDO(q.DO.Not(conds...))
}

func (q questionKnowledgePointDo) Or(conds ...gen.Condition) IQuestionKnowledgePointDo {
	return q.withDO(q.DO.Or(conds...))
}

func (q questionKnowledgePointDo) Select(conds ...field.Expr) IQuestionKnowledgePointDo {
	return q.withDO(q.DO.Select(conds...))
}

func (q questionKnowledgePointDo) Where(conds ...gen.Condition) IQuestionKnowledgePointDo {
	return q.withDO(q.DO.Where(conds...))
}

func (q questionKnowledgePointDo) Order(conds ...field.Expr) IQuestionKnowledgePointDo {
	return q.withDO(q.DO.Order(conds...))
}

func (q questionKnowledgePointDo) Distinct(cols ...field.Expr) IQuestionKnowledgePointDo {
	return q.withDO(q.DO.Distinct(cols...))
}

func (q questionKnowledgePointDo) Omit(cols ...field.Expr) IQuestionKnowledgePointDo {
	return q.withDO(q.DO.Omit(cols...))
}

func (q questionKnowledgePointDo) Join(table schema.Tabler, on ...field.Expr) IQuestionKnowledgePointDo {
	return q.withDO(q.DO.Join(table, on...))
}

func (q questionKnowledgePointDo) LeftJoin(table schema.Tabler, on ...field.Expr) IQuestionKnowledgePointDo {
	return q.withDO(q.DO.LeftJoin(table, on...))
}

func (q questionKnowledgePointDo) RightJoin(table schema.Tabler, on ...field.Expr) IQuestionKnowledgePointDo {
	return q.withDO(q.DO.RightJoin(table, on...))
}

func (q questionKnowledgePointDo) Group(cols ...field.Expr) IQuestionKnowledgePointDo {
	return q.withDO(q.DO.Group(cols...))
}

func (q questionKnowledgePointDo) Having(conds ...gen.Condition) IQuestionKnowledgePointDo {
	return q.withDO(q.DO.Having(conds...))
}

func (q questionKnowledgePointDo) Limit(limit int) IQuestionKnowledgePointDo {
	return q.withDO(q.DO.Limit(limit))
}

func (q questionKnowledgePointDo) Offset(offset int) IQuestionKnowledgePointDo {
	return q.withDO(q.DO.Offset(offset))
}

func (q questionKnowledgePointDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IQuestionKnowledgePointDo {
	return q.withDO(q.DO.Scopes(funcs...))
}

func (q questionKnowledgePointDo) Unscoped() IQuestionKnowledgePointDo {
	return q.withDO(q.DO.Unscoped())
}

func (q questionKnowledgePointDo) Create(values ...*model.QuestionKnowledgePoint) error {
	if len(values) == 0 {
		return nil
	}
	return q.DO.Create(values)
}

func (q questionKnowledgePointDo) CreateInBatches(values []*model.QuestionKnowledgePoint, batchSize int) error {
	return q.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (q questionKnowledgePointDo) Save(values ...*model.QuestionKnowledgePoint) error {
	if len(values) == 0 {
		return nil
	}
	return q.DO.Save(values)
}

func (q questionKnowledgePointDo) First() (*model.QuestionKnowledgePoint, error) {
	if result, err := q.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.QuestionKnowledgePoint), nil
	}
}

func (q questionKnowledgePointDo) Take() (*model.QuestionKnowledgePoint, error) {
	if result, err := q.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.QuestionKnowledgePoint), nil
	}
}

func (q questionKnowledgePointDo) Last() (*model.QuestionKnowledgePoint, error) {
	if result, err := q.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.QuestionKnowledgePoint), nil
	}
}

func (q questionKnowledgePointDo) Find() ([]*model.QuestionKnowledgePoint, error) {
	result, err := q.DO.Find()
	return result.([]*model.QuestionKnowledgePoint), err
}

func (q questionKnowledgePointDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.QuestionKnowledgePoint, err error) {
	buf := make([]*model.QuestionKnowledgePoint, 0, batchSize)
	err = q.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (q questionKnowledgePointDo) FindInBatches(result *[]*model.QuestionKnowledgePoint, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return q.DO.FindInBatches(result, batchSize, fc)
}

func (q questionKnowledgePointDo) Attrs(attrs ...field.AssignExpr) IQuestionKnowledgePointDo {
	return q.withDO(q.DO.Attrs(attrs...))
}

func (q questionKnowledgePointDo) Assign(attrs ...field.AssignExpr) IQuestionKnowledgePointDo {
	return q.withDO(q.DO.Assign(attrs...))
}

func (q questionKnowledgePointDo) Joins(fields ...field.RelationField) IQuestionKnowledgePointDo {
	for _, _f := range fields {
		q = *q.withDO(q.DO.Joins(_f))
	}
	return &q
}

func (q questionKnowledgePointDo) Preload(fields ...field.RelationField) IQuestionKnowledgePointDo {
	for _, _f := range fields {
		q = *q.withDO(q.DO.Preload(_f))
	}
	return &q
}

func (q questionKnowledgePointDo) FirstOrInit() (*model.QuestionKnowledgePoint, error) {
	if result, err := q.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.QuestionKnowledgePoint), nil
	}
}

func (q questionKnowledgePointDo) FirstOrCreate() (*model.QuestionKnowledgePoint, error) {
	if result, err := q.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.QuestionKnowledgePoint), nil
	}
}

func (q questionKnowledgePointDo) FindByPage(offset int, limit int) (result []*model.QuestionKnowledgePoint, count int64, err error) {
	result, err = q.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = q.Offset(-1).Limit(-1).Count()
	return
}

func (q questionKnowledgePointDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = q.Count()
	if err != nil {
		return
	}

	err = q.Offset(offset).Limit(limit).Scan(result)
	return
}

func (q questionKnowledgePointDo) Scan(result interface{}) (err error) {
	return q.DO.Scan(result)
}

func (q questionKnowledgePointDo) Delete(models ...*model.QuestionKnowledgePoint) (result gen.ResultInfo, err error) {
	return q.DO.Delete(models)
}

func (q *questionKnowledgePointDo) withDO(do gen.Dao) *questionKnowledgePointDo {
	q.DO = *do.(*gen.DO)
	return q
}
